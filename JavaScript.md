### 什么是闭包（ closure）？
* 为了说明闭包，创建一个闭包。
```
function hello（）{
//函数执行完毕，变量仍然存在
var num= 100；
var showResult= function（）{ alert （num）；}
 num++；
return showResult ；
}
var showResult= he1lo();
showResult（）//执行结果：弹出101
```
* 执行 hello()后， hello（）闭包内部的变量会存在，而闭包内部函数的内部变量不会存在，使得 JavaScript的垃圾回收机制不会收回hello()占用的资源，因为hell()中内部函数的执行需要依赖 hello()中的变量

### 如何理解 JavaScript中的闭包？
* 闭包就是能够读取其他函数内部变量的函数。
* 闭包的用途有两个，一是可以读取函数内部的变量，二是让这些变量的值始终保持在内存中。

### 闭包的优缺点是什么？
* 优点是不产生全局变量，实现属性私有化缺点是闭包中的数据会常驻内存，在不用的时候需要删除，否则会导致内存溢出（内存泄漏）

### 谈谈你对this对象的理解。
* this是 JavaScript的一个关键字，随着函数使用场合的不同，this的值会发生变化。但是有一个总原则，即this指的是调用函数的那个对象一般情况下，this是全局对象 Global，可以作为方法调用

### JavaScript有哪些垃圾回收机制？
* 标记清除（ mark and sweep）
  * 这是 JavaScript最常见的垃圾回收方式。当变量进入执行环境的时候，比如在函数中声明一个变量，垃圾回收器将其标记为“进入环境”。当变量离开环境的时候（函数执行结束），将其标记为“离开环境”。
  * 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量，以及被环境中变量所引用的变量（闭包）的标记。在完成这些之后仍然存在的标记就是要删除的变量。
* 引用计数（ reference counting）
  * 在低版本的E中经常会发生内存泄漏，很多时候就是因为它采用引用计数的方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数。
  * 当声明了一个变量并将个引用类型赋值给该变量的时候，这个值的引用次数就加1.如果该变量的值变成了另外一个，则这个值的引用次数减1.当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问。
  * 因此，可以将它占用的空间回收，这样垃圾回收器会在运行的时候清理引用次数为0的值占用的空间在正中虽然 JavaScript对象通过标记清除的方式进行垃圾回收，但是BOM与DOM对象是用引用计数的方式回收垃圾的。
  * 也就是说，只要涉及BOM和DOM，就会出现循环引用问题

### 2、列举几种类型的DOM节点
* 有以下几类DOM节点。
  * 整个文档是一个文档（ Document）节点。
  * 每个HTML标签是一个元素（ Element）节点。
  * 每一个HTML属性是一个属性（ Attribute）节点。
  * 包含在HTML元素中的文本是文本（Text）节点

### 谈谈 script标签中 defer和 async属性的区别。
* （1） defer属性规定是否延迟执行脚本，直到页面加载为止， async属性规定脚本一旦可用，就异步执行。
* （2） defer并行加载 JavaScript文件，会按照页面上 script标签的顺序执行， async并行加载 JavaScript文件，下载完成立即执行，不会按照页面上 script标签的顺序执行。

### 对闭包的理解
* 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染；缺点是闭包会常驻内存，增加内存使用量，使用不当很容易造成内存泄漏。在JavaScript中，函数即闭包，只有函数才会产生作用域闭包有3个特性
  * （1）函数嵌套函数。
  * （2）在函数内部可以引用外部的参数和变量
  * （3）参数和变量不会以垃圾回收机制回收

### 解释一下 unshift0方法。
* 该方法在数组启动时起作用，与 push()不同。它将参数成员添加到数组的顶部下面给出一段示例代。
```
var name=["john"]
name.unshift（"charlie"）;
name.unshift（"joseph","Jane"）;
console.log（name）;
 ```
* 输出如下所示
```
[" joseph ", Jane "," charlie "," john "]
```

### 6、encodeR0和 decodeR0的作用是什么？
* encodeURI()用于将URL转换为十六进制编码。而 decodeURI()用于将编码的URL转换回正常URL。

### 为什么不建议在 JavaScript中使用 innerHTML？
* 通过 innerHTML修改内容，每次都会刷新，因此很慢。在 innerHTML中没有验证的机会，因此更容易在文档中插入错误代码，使网页不稳定。

### 什么是构造函数？它与普通函数有什么区别？

* 构造函数是一种特殊的方法，主要用来创建对象时初始化对象，经常与new运算符一起使用，创建对象的语句中构造函数的名称必须与类名完全相同。
* 与普通函数相比，区别如下
  * （1）构造函数只能由new关键字调用
  * （2）构造函数可以创建实例化对象
  * （3）构造函数是类的标志。

### 手写一个JS深拷贝
* 乞丐版
```
 var newObj = JSON.parse( JSON.stringify( someObj ) );
```
* 面试够用版
```
function deepCopy(obj){
    //判断是否是简单数据类型，
    if(typeof obj == "object"){
        //复杂数据类型
        var result = obj.constructor == Array ? [] : {};
        for(let i in obj){
            result[i] = typeof obj[i] == "object" ? deepCopy(obj[i]) : obj[i];
        }
    }else {
        //简单数据类型 直接 == 赋值
        var result = obj;
    }
    return result;
}
```